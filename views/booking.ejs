<div id="app">

</div>


<script src="https://moment.github.io/luxon/global/luxon.min.js"></script>
<script type="module">
    import {createApp, ref, onMounted, computed} from 'https://unpkg.com/vue@3/dist/vue.esm-browser.js'

    createApp({
        setup() {
            const selectedCategory = ref('');
            const services = ref([]);
            const categories = ref([]);
            const selectedServices = ref([]);
            const checkedState = ref({});
            const allServices = ref([]);
            const workers = ref([])
            const highlightedSlots = ref([]);
            const selectedWorker = ref(null)
            const selectedEndTime = ref(null)
            const selectedStart = ref(null);
            const selectedEnd = ref(null);
            const clickedDate = ref(null);
            const bookedDateTime = ref(null);

            const startDateTime = ref(null);
            const endDateTime = ref(null);

            const showFirstPart = ref(true)
            const showSecondPart = ref(false)
            const showTimeTable = ref(false)
            const showClientForm = ref(false)
            const selectedDate = ref('');
            const slots = ref([])
            const clientData = ref({
                clientName: '',
                clientTel: '',
                clientEmail: '',
                clientAdditionalInfo: '',
            });

            const clientId = ref(null);
            const orderId = ref(null);


            // Method to handle form submission
            const submitClientData = async (event, date) => {
                event.preventDefault(); // Prevent the default form submission behavior
                const {clientName, clientTel, clientEmail, clientAdditionalInfo} = clientData.value;

                const start = selectedStart.value;
                const end = selectedEnd.value;

                date = selectedDate.value;
                //console.log("DATE", selectedDate.value);

                try {
                    // Send client data
                    await sendClientData(clientName, clientTel, clientEmail, clientAdditionalInfo);

                    const clientID = clientId.value;

                    await sendOrder(clientID, totalPrice);

                    // const orderId = orderId.value;
                    console.log("order_id...", orderId.value);

                    await sendOrderServices(orderId, selectedServices);

                    // Schedule the event after client data is sent
                    console.log("DATE", clickedDate.value);
                    await scheduleEvent(start, end, clickedDate, selectedDate, clientName, clientTel, clientEmail, clientAdditionalInfo);

                    //   console.log("appointmentId -- ", appointmentId.value);
                } catch (error) {
                    console.error('Error:', error);
                }
            };

            // Async function to send the client id into appointments table
            async function sendOrder(clientID, totalPrice) {
                const clientId = clientID.clientId;

                try {
                    const response = await fetch(`/order`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            clientId,
                            totalPrice: totalPrice.value
                        }),
                    });

                    if (response.ok) {
                        orderId.value = await response.json();
                    }
                } catch (error) {
                    console.error('Error sending client data:', error);
                }
            }

            //send selected services to appointment_services table where appointment_services.appointment_id = appointments.appointment_id
            async function sendOrderServices(orderId, selectedServices) {
                console.log("new:orderId", orderId.value)
                //const appointment_id = orderId.value;
                try {
                    const response = await fetch(`/order_services`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            selectedServices,
                            orderId: orderId.value,
                        }),
                    });

                    if (response.ok) {
                        const result = await response.json();
                        console.log('Client data sent successfully545:', result);
                    } else {
                        throw new Error(`${response.status} ${response.statusText}`);
                    }
                } catch (error) {
                    console.error('Error sending client data:', error);
                }
            }

            // Async function to send the client data
            async function sendClientData(clientName, clientTel, clientEmail, clientAdditionalInfo) {
                try {
                    console.log("clientAdditionalInfo", clientAdditionalInfo);
                    const response = await fetch(`/clients`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            clientName,
                            clientTel,
                            clientEmail,
                            clientAdditionalInfo,
                        }),
                    });

                    if (response.ok) {
                        clientId.value = await response.json();
                    } else {
                        throw new Error(`${response.status} ${response.statusText}`);
                    }
                } catch (error) {
                    console.error('Error sending client data:', error);
                }
            }

            async function scheduleEvent(start, end, clickedDate, selectedDate, clientName, clientTel, clientEmail, clientAdditionalInfo) {
                try {

                    console.log("selectedDate", clickedDate.value)
                    const selectedDateString = typeof clickedDate === 'string' ? clickedDate : clickedDate.value || luxon.DateTime.local().toISODate();

                  //  startDateTime.value = "2023-12-30T09:00";
                  //  endDateTime.value = "2023-12-30T10:00";
                    endDateTime.value = selectedDateString + "T" + end;
                    startDateTime.value = selectedDateString + "T" + start;

                    console.log("startDateTime!", startDateTime.value);
                    //console.log("selectedServices.value!", selectedServices.value)

                    const scheduleResponse = await http.post('/schedule-event', {
                        start: startDateTime.value,
                        end: endDateTime.value,
                        clientName,
                        clientTel,
                        clientEmail,
                        clientAdditionalInfo,
                        selectedServices: selectedServices.value,
                        selectedWorker: selectedWorker.value,
                    });

                    if (scheduleResponse) {
                        console.log('Event scheduled successfully:', scheduleResponse);
                    } else {
                        console.log('Error scheduling event3:', scheduleResponse);
                        // Handle error here, you may throw an error or show an error message
                    }
                } catch (error) {
                    console.error('Error scheduling event4:', error);
                    // Handle error here, you may throw an error or show an error message
                }
            }

            const loadAndDisplayServices = async () => {
                try {

                    const response = await axios.get(`/services/${selectedCategory.value}`);
                    services.value = response.data;

                } catch (error) {
                    console.error('Error fetching services:', error);
                }
            };

            const getCategories = async () => {
                try {
                    const response = await axios.get('/category');
                    categories.value = response.data;

                } catch (error) {
                    console.error('Error fetching categories:', error);
                }
            };

            const toggleServiceSelection = (service) => {

                const serviceToToggle = allServices.value.find(s => s.service_id === service.service_id)

                const isSelected = selectedServices.value.some(selectedService => selectedService.service_id === service.service_id)
                if (isSelected) {
                    // Service is already selected, uncheck and remove it
                    const indexToRemove = selectedServices.value.findIndex(selectedService => selectedService.service_id === service.service_id);
                    selectedServices.value.splice(indexToRemove, 1);
                    checkedState.value[service.service_id] = false;
                } else {
                    // Service is not selected, check it and add to selectedServices
                    selectedServices.value.push(serviceToToggle);
                    checkedState.value[service.service_id] = true;
                }
            };

            const totalDuration = computed(() => {
                return selectedServices.value.reduce((total, service) => {
                    return total + service.duration_minutes
                }, 0)
            });

            const totalPrice = computed(() => {
                return selectedServices.value.reduce((total, service) => {
                    console.log("price? ", total + service.price);
                    return total + service.price
                }, 0)
            });

            const formattedTIme = (durationInMinutes) => {
                const hours = Math.floor(durationInMinutes / 60);
                const minutes = durationInMinutes % 60;

                // Format the duration as per your requirement
                return `${hours}.${minutes}h`;
            };

            const formattedSelectedServices = (selectedServices = []) => {

                if (selectedServices.length === 0) {
                    console.log("no services selected");
                    return 'nono';
                }
                return selectedServices.map(service => service.name).join(', ')

            }

            const isSubmitDisabled = computed(() => {
                return selectedServices.value.length === 0;
            });

            async function fetchWorkers() {
                const selectedServiceIds = selectedServices.value.map(service => service.service_id);

                const response = await fetch('/workers', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(selectedServiceIds)
                })
                if (!response.ok) {
                    throw new Error(`Request failed with status ${response.status}`);
                }
                workers.value = await response.json()
                showFirstPart.value = false
                showSecondPart.value = true
            }

            const handleSelectedWorkerChange = () => {
                console.log("worker handled", selectedWorker.value);
                fetchSlots(selectedDate.value);
                showTimeTable.value = true
            };

            const handleDateChange = () => {
                fetchSlots(selectedDate.value);
                console.log("date handled", selectedDate.value)
            };


            const fetchSlots = async (date) => {
                selectedDate.value = date || luxon.DateTime.local().toISODate();
                //get total duration of selected services

                console.log("date", selectedDate);

                try {
                    const responseData = await http.get(`/timeslots?worker=${selectedWorker.value}&date=${selectedDate.value}`);
                    const currentDate = luxon.DateTime.fromISO(selectedDate.value);
                    const endDate = currentDate.plus({day: 6});
                    console.log("responseData", currentDate, endDate);

                    slots.value = responseData
                        .map(slot => {
                            //console.log("Slot start:", slot.start); // Add this line for additional logging
                            const slotDate = luxon.DateTime.fromISO(slot.start).toISODate();
                            console.log("slotDate", slotDate)
                            return {
                                start: slot.start, // Add this line for additional logging
                                end: slot.end, // Add this line for additional logging
                                slotDate: slotDate, // Add this line for additional logging
                                startTimeFormatted: luxon.DateTime.fromISO(slot.start).toFormat('HH:mm'),
                                endTimeFormatted: luxon.DateTime.fromISO(slot.end).toFormat('HH:mm'),
                                isAvailable: slot.isAvailable,
                            };
                        })
                        .filter(slot => {
                            const slotDate = slot.slotDate;
                            const currentDateString = currentDate.toISODate();
                            const endDateString = endDate.toISODate();

                            return currentDateString <= slotDate && slotDate <= endDateString;
                        });

                    console.log("slot", slots)

                } catch (error) {
                    console.error('Error fetching available slots:', error);
                    // Error modal is handled within the http utility
                }
            };

            const uniqueDates = computed(() => {

                return [...new Set(slots.value.map(s => s.slotDate))];
            });

            const slotsOnDate = computed(() => {
                return slots.value.filter(s => {
                    return s.slotDate === selectedDate.value;
                });
            });

            const uniqueTimes = computed(() => {
                const times = slots.value.map(s => s.startTimeFormatted);
                return [...new Set(times)];
            })

            const getSlot = (time, date) => {
                return slots.value.find(slot => slot.startTimeFormatted === time && slot.slotDate === date);
            };


            const handleSlotMouseOver = (time, currentDate, totalSlots) => {
                // const totalSlots = totalDuration.value / 15; // Assuming each slot is 15 minutes

                const currentSlots = slots.value.filter(
                    slot => slot.startTimeFormatted === time && slot.slotDate === currentDate
                );

                if (currentSlots.length === 0) {
                    console.log('No slots available for the selected time and date.');
                    return;
                }

                const currentIndex = slots.value.findIndex(
                    s => s.startTimeFormatted === time && s.slotDate === currentDate
                );

                const {allAvailable, highlighted, end} = checkConsecutiveSlots(currentIndex, totalSlots);

                if (allAvailable) {
                    highlightedSlots.value = highlighted;

                    // Highlight slots in the UI
                    slots.value.forEach(slot => {
                        if (slot) {
                            slot.highlighted = highlighted.includes(slot);
                        }
                    });

                    // Store the end time
                    selectedEndTime.value = end;
                } else {
                    highlightedSlots.value = [];

                    slots.value.forEach(slot => {
                        if (slot) {
                            slot.highlighted = false;
                        }
                    });
                    console.log('Not available');

                }
            };

            // Function to check if there are enough consecutive slots
            const checkConsecutiveSlots = (currentIndex, totalSlots) => {
                totalSlots = totalDuration.value / 15; // Assuming each slot is 15 minutes

                let allAvailable = true;
                const highlighted = [];
                let end = null;

                for (let i = 0; i < totalSlots; i++) {
                    const indexToCheck = currentIndex + i;
                    if (indexToCheck >= 0 && indexToCheck < slots.value.length) {
                        highlighted.push(slots.value[indexToCheck]);
                        if (!slots.value[indexToCheck].isAvailable) {
                            allAvailable = false;
                            break;
                        }

                        end = slots.value[indexToCheck].endTimeFormatted;
                    } else {
                        allAvailable = false; // Slot index out of bounds
                        break;
                    }
                }

                return {allAvailable, highlighted, end};
            };

            const isSlotHighlighted = (time, date) => {
                const slot = getSlot(time, date);
                return slot && highlightedSlots.value.includes(slot);
            };


            const isSlotAvailable = (slot) => {
                return slot.isAvailable;
            };

            const handleSlotClick = (time, date, totalSlots) => {
                const slot = getSlot(time, date);

                if (slot) {
                    const currentIndex = slots.value.findIndex(s => s.startTimeFormatted === time && s.slotDate === date);

                    const {allAvailable, end} = checkConsecutiveSlots(currentIndex, totalSlots);

                    if (allAvailable && isSlotAvailable(slot)) {
                        selectedStart.value = slot.startTimeFormatted;
                        selectedEnd.value = end || selectedEndTime.value;
                        showClientForm.value = true;
                        showTimeTable.value = false;
                        showSecondPart.value = false;
                        console.log('Clicked on time:', slot.startTimeFormatted);
                        clickedDate.value = slot.slotDate;
                        bookedDateTime.value = slot.slotDate + " at " + slot.startTimeFormatted;
                        console.log("clickedDate", startDateTime.value);

                    } else {
                        console.log('Slot is not available or there are not enough consecutive slots');
                    }
                } else {
                    console.log('Slot not found');
                }
            };


            const cancelBooking = () => {
                // Reset all selected data and go back to the initial state
                selectedCategory.value = '';
                services.value = [];
                selectedServices.value = [];
                checkedState.value = {};
                workers.value = [];
                highlightedSlots.value = [];
                selectedWorker.value = null;
                selectedEndTime.value = null;
                selectedStart.value = null;
                selectedEnd.value = null;
                clickedDate.value = null;

                // Show the first part of the booking form
                showFirstPart.value = true;
                showSecondPart.value = false;
                showTimeTable.value = false;
                showClientForm.value = false;
            };
            const isSubmitRollback = computed(() => {
                return selectedServices.value.length === 0 && !showFirstPart;
            });

            onMounted(async () => {

                // Fetch categories when the component is mounted
                getCategories();
                const response = await axios.get('/services');
                allServices.value = response.data


            });

            return {
                totalPrice,
                startDateTime,
                bookedDateTime,
                formattedTIme,
                formattedSelectedServices,
                uniqueDates,
                getSlot,
                isSlotHighlighted,
                slotsOnDate,
                uniqueTimes,
                selectedCategory,
                selectedServices,
                totalDuration,
                services,
                handleDateChange,
                handleSlotClick,
                isSlotAvailable,
                highlightedSlots,
                handleSlotMouseOver,
                categories,
                checkedState,
                selectedDate,
                handleSelectedWorkerChange,
                isSubmitDisabled,
                workers,
                slots,
                selectedWorker,
                showFirstPart,
                showSecondPart,
                showTimeTable,
                showClientForm,
                fetchWorkers,
                loadAndDisplayServices,
                toggleServiceSelection,
                submitClientData,
                clientData,
                cancelBooking,
            };
        },
        data() {
            return {};
        },
        methods: {},
        template: `
            <div class="booking_container">
                <div class="services_selection" v-if="showFirstPart">
                    <div class="first_part">
                        <div class="blockTest">
                            <h2>Category</h2>

                            <div class="category_selection">
                                <label for="categorySelect">Select a category:</label>
                                <select id="categorySelect" v-model="selectedCategory" @change="loadAndDisplayServices">
                                  <option v-for="category in categories" :key="category.category_id" :value="category.category_id">
                                    {{ category.name }}
                                  </option>
                                </select>
                            </div>
                        </div>
                        <div id="serviceCheckboxes">
                            <h2>Service name</h2>

                            <label v-for="service in services" :key="service.service_id">
                                <li>
                                    <input
                                        type="checkbox"
                                        :checked="checkedState[service.service_id]"
                                        @change="toggleServiceSelection(service, allServices)"
                                    >
                                    {{ service.name }}<br>
                                    <span class="duration">Duration: {{ formattedTIme(service.duration_minutes) }}</span>
                                </li>
                            </label>
                        </div>
                    </div>

                    <br>
                </div>
                <div id="second-part" v-if="showSecondPart">

                    <div v-if="workers.length">
                        <p>Chose worker: <!--{{ workers }}--></p>
                    </div>
                    <div v-else>
                        No workers found
                    </div>

                    <select v-model="selectedWorker" @change="handleSelectedWorkerChange">
                        <option v-for="worker in workers" :key="worker.worker_id" :value="worker.worker_id">{{ worker.name }}</option>
                    </select>


                    <label for="selected-date">Select Date:</label>
                    <input  v-model="selectedDate" type="date" id="selected-date" @change="handleDateChange">
                </div>

        <!--TimeTable-->

            <div v-if="showTimeTable">
             <table>
                <thead>
                  <tr>
                    <th></th>
                    <th v-for="date in uniqueDates">{{ date }}</th>
                  </tr>
                </thead>
                <tbody>
                  <tr v-for="time in uniqueTimes" :key="time">
                    <td>{{ time }}</td>
                        <td
                            v-for="date in uniqueDates"
                            :key="date"
                            @mouseover="handleSlotMouseOver(time, date)"
                            @click="handleSlotClick(time, date, slot)"
                            :class="{'unavailable': !getSlot(time, date).isAvailable, 'highlighted-slot': isSlotHighlighted(time, date)}"
                        >

                      <div v-if="getSlot(time, date)">
                        {{ getSlot(time, date).isAvailable ? '' : '' }}
                      </div>
                      <div v-else>
                        No slot available
                      </div>
                    </td>
                  </tr>
                </tbody>
              </table>
            </div>
                <div class="final_part" v-if="showClientForm">
                    <div class="client_info">
                        <div class="final_info time_info">
                            <h3>Selected time</h3>
                            <p>{{ bookedDateTime }}</p>
                        </div>

                        <div class="final_info salon_info">
                            <h4>Salon</h4>
                            <div class="salon_info">
                                <p>Explorer HAIR STUDIO</p>
                                <p>Kai 1,Explorer ärimaja</p>
                            </div>
                        </div>

                        <div class="final_info worker_info">
                            <h4>Worker</h4>
                            <p v-for="worker in workers" :key="worker.worker_id" :value="worker.worker_id">{{ worker.name }}</p>
                        </div>
                        <div class="final_info selectedServices_info">
                            <h3>Selected services</h3>
                            <p>{{formattedSelectedServices(selectedServices)}}</p>
                        </div>
                        <div class="final_info totalPrice_info">
                            <h4>Price</h4>
                            <p>{{ totalPrice }}€</p>
                        </div>
                    </div>

                    <div class="client_form" >
                        <h2>Client Information Form</h2>

                        <form class="client-form">
                          <div class="form-group">
                            <label for="clientName">Name:</label>
                            <input v-model="clientData.clientName" type="text" id="clientName" name="clientName" required>
                          </div>

                          <div class="form-group">
                            <label for="clientTel">Telephone Number:</label>
                            <input v-model="clientData.clientTel" type="tel" id="clientTel" name="clientTel" required>
                          </div>

                          <div class="form-group">
                            <label for="clientEmail">Email:</label>
                            <input v-model="clientData.clientEmail" type="email" id="clientEmail" name="clientEmail" required>
                          </div>

                          <div class="form-group">
                            <label for="clientAdditionalInfo">Additional Info:</label>
                            <input v-model="clientData.clientAdditionalInfo" type="text" id="clientAdditionalInfo" name="clientAdditionalInfo">
                          </div>

                          <div class="form-group">
                            <button id="send_user_data" type="button" @click="submitClientData">Send User Data</button>
                          </div>
                        </form>
                    </div>
                </div>
                <div class="info_about_booking">
                    <p v-if="selectedServices" id="selected-services">{{formattedSelectedServices(selectedServices)}}</p>
                    <p id="duration">{{ formattedTIme(totalDuration) }}</p>
                    <button class="button_booking_container" id="cancelButton" type="button" @click="cancelBooking">Cancel</button>
                    <button class="button_booking_container" id="submitButton" type="button" @click="fetchWorkers" :disabled="isSubmitDisabled">Submit</button>

                </div>
            </div>
        `,
    }).mount('#app');
</script>
