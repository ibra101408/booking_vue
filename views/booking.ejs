<div id="app">

</div>


<script src="https://moment.github.io/luxon/global/luxon.min.js"></script>
<script type="module">
    import {createApp, ref, onMounted, computed} from 'https://unpkg.com/vue@3/dist/vue.esm-browser.js'

    createApp({
        setup() {
            const selectedCategory = ref('');
            const services = ref([]);
            const categories = ref([]);
            const selectedServices = ref([]);
            const checkedState = ref({});
            const allServices = ref([]);
            const workers = ref([])
            const highlightedSlots = ref([]);
            const selectedWorker = ref(null)
            const selectedEndTime = ref(null)
            const selectedStart = ref(null);
            const selectedEnd = ref(null);

            const showSecondPart = ref(false)
            const showTimeTable = ref(false)
            const showClientForm = ref(false)

            const selectedDate = ref('');
            const slots = ref('')
            const clientData = ref({
                clientName: '',
                clientTel: '',
                clientEmail: '',
            });

            const clientId = ref(null);
            const appointmentID = ref(null);


            // Method to handle form submission
            const submitClientData = async (event, date) => {
                event.preventDefault(); // Prevent the default form submission behavior
                const { clientName, clientTel, clientEmail } = clientData.value;

                const start = selectedStart.value;
                const end = selectedEnd.value;

                date = selectedDate.value;
                //console.log("DATE", selectedDate.value);

                try {
                    // Send client data
                    await sendClientData(clientName, clientTel, clientEmail);

                    const clientID = clientId.value;

                    await sendAppointments(clientID);

                    //const appointmentIds = appointmentID.value;

                    await sendAppointmentServices(appointmentID, selectedServices);
                    // Schedule the event after client data is sent
                    await scheduleEvent(start, end, date, selectedDate, clientName, clientTel, clientEmail, clientID);

                 //   console.log("appointmentId -- ", appointmentId.value);
                } catch (error) {
                    console.error('Error:', error);
                }
            };

            // Async function to send the client id into appointments table
            async function sendAppointments(clientID) {
                //console.log("client point n3", clientID);
                const clientId = clientID.clientId;
                try {
                    const response = await fetch(`/appointments`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            clientId,
                        }),
                    });
                    console.log("client point n2 APpointments");

                    if (response.ok) {
                        appointmentID.value = await response.json();
                    }
                } catch (error) {
                    console.error('Error sending client data:', error);
                }
            }

            //send selected services to appointment_services table where appointment_services.appointment_id = appointments.appointment_id
            async function sendAppointmentServices(appointmentID, selectedServices) {

                const appointment_id = appointmentID.value.appointmentId;
                try {
                    const response = await fetch(`/appointment_services`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            selectedServices,
                            appointment_id,
                        }),
                    });
                    //console.log("client point n2 APpointments");

                    if (response.ok) {
                        const result = await response.json();
                        console.log('Client data sent successfully:', result);
                    } else {
                        throw new Error(`${response.status} ${response.statusText}`);
                    }
                } catch (error) {
                    console.error('Error sending client data:', error);
                }
            }

            // Async function to send the client data
            async function sendClientData(clientName, clientTel, clientEmail) {
                try {
                    const response = await fetch(`/clients`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            clientName,
                            clientTel,
                            clientEmail,
                        }),
                    });

                    if (response.ok) {
                        clientId.value = await response.json();
                    } else {
                        throw new Error(`${response.status} ${response.statusText}`);
                    }
                } catch (error) {
                    console.error('Error sending client data:', error);
                }
            }

            // Async function to schedule the event
            async function scheduleEvent(start, end, date, selectedDate, clientName, clientTel, clientEmail, clientID) {
                try {

                    selectedDate.value = date || luxon.DateTime.local().toISODate();
                    const startDateTime = date + 'T' + start;
                    const endDateTime = date + 'T' + end;

                    const clientId = clientID.clientId;

                    const scheduleResponse = await fetch(`/google/schedule_event`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            start: startDateTime,
                            end: endDateTime,
                            clientName,
                            clientTel,
                            clientId,
                            clientID,
                            clientEmail,
                            selectedServices: selectedServices.value,
                            selectedWorker: selectedWorker.value,
                            //appointmentId,
                        }),
                    });

                    if (scheduleResponse.ok) {
                        const result = await scheduleResponse.json();
                        console.log('Event scheduled successfully:', result);
                    } else {
                        const errorMessage = scheduleResponse;
                        console.log("Error scheduling event:", errorMessage);
                        throw new Error(`${scheduleResponse.status} ${scheduleResponse.statusText || errorMessage}`);
                    }
                } catch (error) {
                    console.error('Error scheduling event:', error);
                }
            }

            const loadAndDisplayServices = async () => {
                try {
                    const response = await axios.get(`/services/${selectedCategory.value}`);
                    services.value = response.data;

                } catch (error) {
                    console.error('Error fetching services:', error);
                }
            };

            const getCategories = async () => {
                try {
                    const response = await axios.get('/category');
                    categories.value = response.data;
                } catch (error) {
                    console.error('Error fetching categories:', error);
                }
            };

            const toggleServiceSelection = (service) => {

                const serviceToToggle = allServices.value.find(s => s.service_id === service.service_id)
               // console.log("toggled, ", serviceToToggle);

                const isSelected = selectedServices.value.some(selectedService => selectedService.service_id === service.service_id)
                if (isSelected) {
                    // Service is already selected, uncheck and remove it
                    const indexToRemove = selectedServices.value.findIndex(selectedService => selectedService.service_id === service.service_id);
                    selectedServices.value.splice(indexToRemove, 1);
                    checkedState.value[service.service_id] = false;
                } else {
                    // Service is not selected, check it and add to selectedServices
                    selectedServices.value.push(serviceToToggle);
                    checkedState.value[service.service_id] = true;
                }
            };

            const totalDuration = computed(() => {
                return selectedServices.value.reduce((total, service) => {
                    return total + service.duration_minutes
                }, 0)
            });

            const formatTime = computed(() => {
                let minutes = totalDuration.value;

                let hours = Math.floor(minutes / 60)
                let mins = minutes % 60

                return hours + '.' + mins.toString().padStart(2, '0') + 'h'
            });

            const isSubmitDisabled = computed(() => {
                return selectedServices.value.length === 0;
            });

            async function fetchWorkers() {
                const selectedServiceIds = selectedServices.value.map(service => service.service_id);

                const response = await fetch('/workers', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(selectedServiceIds)
                })
                if (!response.ok) {
                    throw new Error(`Request failed with status ${response.status}`);
                }
                workers.value = await response.json()

                showSecondPart.value = true
            }

            const handleSelectedWorkerChange = () => {
                console.log("worker handled", selectedWorker.value);
                fetchSlots(selectedDate.value);
                showTimeTable.value = true
            };

            const handleDateChange = () => {
                fetchSlots(selectedDate.value);
                console.log("date handled", selectedDate.value)
            };

            // Fetch slots function
            const fetchSlots = async (date) => {
                selectedDate.value = date || luxon.DateTime.local().toISODate();
                //get total duration of selected services

                console.log("date", selectedDate);

                try {
                    const responseData = await http.get(`/timeslots?worker=${selectedWorker.value}&date=${selectedDate.value}`);

                    slots.value = responseData.map(slot => ({
                        startTimeFormatted: luxon.DateTime.fromISO(slot.start).toFormat('HH:mm'),
                        endTimeFormatted: luxon.DateTime.fromISO(slot.end).toFormat('HH:mm'),
                        isAvailable: slot.isAvailable,
                    }));

                } catch (error) {
                    console.error('Error fetching available slots:', error);
                    // Error modal is handled within the http utility
                }
            };

            const handleSlotMouseOver = (slot) => {
                const totalSlots = totalDuration.value / 15; // Assuming each slot is 15 minutes

                const currentIndex = slots.value.findIndex((s) => s.startTimeFormatted === slot.startTimeFormatted);

                let allAvailable = true;
                const highlighted = [];
                let end = null;

                for (let i = 0; i < totalSlots; i++) {
                    const indexToCheck = currentIndex + i;
                    if (indexToCheck >= 0 && indexToCheck < slots.value.length) {
                        highlighted.push(slots.value[indexToCheck]);
                        if (!slots.value[indexToCheck].isAvailable) {
                            allAvailable = false;
                            break;
                        }

                        end = slots.value[indexToCheck].endTimeFormatted;

                    } else {
                        allAvailable = false; // Slot index out of bounds
                        break;
                    }
                }

                if (allAvailable) {
                    highlightedSlots.value = highlighted;

                    //store the end time
                    selectedEndTime.value = end;
                   // console.log('All consecutive slots are available');
                } else {
                    highlightedSlots.value = [];
                    console.log('Not available');
                }
            };

            const isSlotAvailable = (slot) => {
                return slot.isAvailable;
            };


            const handleSlotClick = (slot) => {
                if (isSlotAvailable(slot)) {

                    slot.value = {
                        start: slot.startTimeFormatted,
                        end: selectedEndTime.value,
                    };
                    selectedStart.value = slot.value.start;
                    selectedEnd.value = slot.value.end;
                   // console.log("in hancle click on slot: ", slot.value)

                    showClientForm.value = true
                    showTimeTable.value = false
                    // Process the click only if the slot is available
                    console.log('Clicked on time:', slot.startTimeFormatted);
                } else {
                    console.log('Slot is not available');
                }
            };

            onMounted(async () => {

                // Fetch categories when the component is mounted
                getCategories();
                const response = await axios.get('/services');
                allServices.value = response.data


            });

            return {
                formatTime,
                selectedCategory,
                selectedServices,
                totalDuration,
                services,
                handleDateChange,
                handleSlotClick,
                isSlotAvailable,
                highlightedSlots,
                handleSlotMouseOver,
                categories,
                checkedState,
                selectedDate,
                handleSelectedWorkerChange,
                isSubmitDisabled,
                workers,
                slots,
                selectedWorker,
                showSecondPart,
                showTimeTable,
                showClientForm,
                fetchWorkers,
                loadAndDisplayServices,
                toggleServiceSelection,
                submitClientData,
                clientData,
            };
        },
        data() {
            return {};
        },
        methods: {},
        template: `
            <div class="booking_container">
                <div class="first_part">
                    <label for="categorySelect">Select a category:</label>
                    <select id="categorySelect" v-model="selectedCategory" @change="loadAndDisplayServices">
                        <option value="" disabled selected>Select category</option>
                        <option v-for="category in categories" :key="category.category_id" :value="category.category_id">{{ category.name }}</option>
                    </select>

                    <div id="serviceCheckboxes">
                        <label v-for="service in services" :key="service.service_id">
                            <input
                            type="checkbox"
                                :checked="checkedState[service.service_id]"
                                @change="toggleServiceSelection(service, allServices)"
                            >
                            {{ service.name }}
                        </label>
                    </div>

                    <p id="selected-services">{{selectedServices.map(service => service.name)}}</p>
                    <p id="duration">{{formatTime}}</p>


                    <button id="submitButton" type="button" @click="fetchWorkers" :disabled="isSubmitDisabled">Submit</button>

                    <br>
                </div>
                <div v-if="showSecondPart">

                    <div v-if="workers.length">
                        <p>Workers: {{ workers }}</p>
                    </div>
                    <div v-else>
                        No workers found
                    </div>

                    <select v-model="selectedWorker" @change="handleSelectedWorkerChange">
                        <option v-for="worker in workers" :key="worker.worker_id" :value="worker.worker_id">{{ worker }}</option>
                    </select>


                    <label for="selected-date">Select Date:</label>
                    <input  v-model="selectedDate" type="date" id="selected-date" @change="handleDateChange">
                </div>

        <!--TimeTable-->

                <div v-if="showTimeTable">
                    <table id="available-slots-table">
                        <thead>
                        <tr>
                            <th scope="col">Start Time</th>
                        </tr>
                        </thead>
                        <tbody>
                             <tr
                                v-for="slot in slots"
                                :key="slot.start"
                                @mouseover="handleSlotMouseOver(slot)"
                                :class="{ 'unavailable-slot': !isSlotAvailable(slot), 'highlighted-slot': highlightedSlots.includes(slot) }"
                                    @click="handleSlotClick(slot)"
                             >
                                <td>{{ slot }}</td>
                             </tr>
                       </tbody>
                    </table>

                </div>

                <div class="client_form" v-if="showClientForm">
                    <h2>Client Information Form</h2>

                    <form>
                        <label for="clientName">Name:</label>
                        <input v-model="clientData.clientName" type="text" id="clientName" name="clientName" required>

                        <br>
                        <label for="clientTel">Telephone Number:</label>
                        <input v-model="clientData.clientTel" type="tel" id="clientTel" name="clientTel">

                        <br>
                        <label for="clientEmail">Email:</label>
                        <input v-model="clientData.clientEmail" type="email" id="clientEmail" name="clientEmail">

                        <br>
                        <button id="send_user_data" type="submit" @click="submitClientData">Send User Data</button>
                    </form>
                </div>
            </div>
        `,
    }).mount('#app');
</script>
